# 实验五：不同形式级数求和的数值稳定性比较实验报告

## 1. 实验目的
1. 实现并比较三种不同形式的调和级数求方法和
2. 观察和量化不同计算形式在数值精度上的差异
3. 理解灾难性抵消对数值计算的影响
4. 分析不同求和方法的误差增长趋势

## 2. 实验原理
### 2.1 三种级数形式
1. 交错级数形式：

$$ S_N^{(1)} = \sum_{n=1}^{2N} (-1)^n \frac{n}{n+1} $$

2. 两项求和相减形式：

$$ S_N^{(2)} = -\sum_{n=1}^{N} \frac{2n-1}{2n} + \sum_{n=1}^{N} \frac{2n}{2n+1} $$

3. 直接求和形式：

$$ S_N^{(3)} = \sum_{n=1}^{N} \frac{1}{2n(2n+1)} $$

### 2.2 相对误差计算
以 $S_N^{(3)}$ 为参考值，计算其他两种方法的相对误差：

$$ \text{Err}_1 = \left| \frac{S_N^{(1)} - S_N^{(3)}}{S_N^{(3)}} \right| $$
$$ \text{Err}_2 = \left| \frac{S_N^{(2)} - S_N^{(3)}}{S_N^{(3)}} \right| $$

## 3. 实验方法
### 3.1 代码实现
1. `sum_S1(N)` 函数实现：
   - （描述实现方法）
A:使用循环从 1 到 2N，计算每一项 ((−1)^n)⋅ n/(n+1)并累加求和。
2. `sum_S2(N)` 函数实现：
   - （描述实现方法）
A:分别计算两个独立的和：∑(2n−1)/2n和 ∑(2n)/(2n+1)，然后将第二个和减去第一个和得到结果
3. `sum_S3(N)` 函数实现：
   - （描述实现方法）
A:使用循环从 1 到 N，计算每一项1/(2n(2n+1))并累加求和。
### 3.2 数据收集与处理
1. N值选取：使用 `np.logspace(0, 4, 50)` 在对数尺度上取点
2. 计算三种方法的求和结果
   A:对每个 N 值，分别计算 S_N^(1)、S_N^(2)和 S_N^(3)。
3. 计算相对误差
   A:根据公式计算 Err1和 Err2。
4. 绘制双对数误差图
   A:使用 Matplotlib 绘制相对误差随 N 变化的双对数图。

## 4. 实验结果
### 4.1 数据记录
| N | $S_N^{(1)}$ | $S_N^{(2)}$ | $S_N^{(3)}$ | $\text{Err}_1$ | $\text{Err}_2$ |
|---|-------------|-------------|-------------|----------------|----------------|
| 10 |     0.283609549205524  | 0.283609549205526 |  0.283609549205524 |  0.000000000000000  |  0.000000000000005  |      
| 100 |    0.304371445140066  | 0.304371445140021 |  0.304371445140066 |  0.000000000000003  |  0.000000000000151  |
| 1000 |   0.306603006815121  | 0.306603006813361 |  0.306603006815125 |  0.000000000000012  |  0.000000000005751  |  
| 10000 |  0.306827821314915  | 0.306827821297702 |  0.306827821314931 |  0.000000000000053  |   0.000000000056153 |  

### 4.2 误差分析图
（在此插入相对误差随N变化的双对数图）

![image](https://github.com/user-attachments/assets/1384a999-5bd3-4944-b363-7a25061b0199)

## 5. 分析与讨论
### 5.1 误差大小比较
1. 不同方法的误差比较：
   - （分析哪种方法误差更小）
   - （分析误差增长速度）
     A:从数据记录和误差分析图可以看出，S_N^(1)的相对误差Err1明显小于S_N^(2)的相对误差Err2。在 N=10000 时，Err1≈5.3×10^−14，而Err2≈5.6×10^-9，后者比前者大了约 5 个数量级。
     S_N^(2)的误差增长速度明显快于S_N^(1)。随着 N 增大，Err2呈现快速上升趋势，而 Err1
增长较为缓慢。
2. 灾难性抵消分析：
   - （分析 $S_N^{(2)}$中两个内部和的变化）
   - （解释为什么会发生灾难性抵消）
   A:在S_N^(2)的计算中，两个内部和∑(2n−1)/2n和 ∑(2n)/(2n+1)都是接近 1 的较大值。当 N 较大时，这两个和的绝对值都接近 N，但它们的差值却是一个远小于 N 的值。
     这两个相近的大数相减时，较低有效位的数字会被舍入误差填满，导致结果丢失大量有效数字，这就是灾难性抵消现象。
### 5.2 误差增长行为
1. 误差与N的幂律关系：
   - （分析双对数图的线性部分）
   - （估算幂指数p）
    A:从双对数图可以看出，Err1和 Err2随 N 的变化呈现出近似的直线关系，说明误差与 N 的某个幂次成正比。
      对于S_N^(1)误差增长较慢，斜率约为 0.5，即 E∝N^0.5。
      对于S_N^(2)误差增长较快，斜率约为 1.0，即 E∝N^1.0。
2. 误差增长原因：
   - （从数值计算角度解释误差增长的原因）
   A:S_N^(1)的误差主要来源于浮点运算的舍入误差，随着项数增加，舍入误差逐渐累积，但由于是交错级数，正负项相互抵消，一定程度上抑制了误差增长。
     S_N^(2)的误差除了舍入误差外，还受到灾难性抵消的严重影响。两个相近的大数相减导致有效数字大量丢失，使得误差随 N 线性增长。
## 6. 结论
1. 不同计算形式的数值稳定性比较
   A: S_N^(3)最稳定，因为它是直接求和正项级数，没有符号变化，误差累积最少。
      S_N^(2)次之，虽然存在符号交替，但误差增长较慢。
      S_N^(1)最不稳定，由于涉及两个相近大数的相减，容易发生灾难性抵消，导致误差急剧增大。
3. 灾难性抵消对计算精度的影响
   A:灾难性抵消会显著降低计算精度，使结果的有效数字大量减少。
4. 数学等价与数值计算的关系
   A:数学上等价的表达式在数值计算中可能表现出完全不同的稳定性。

## 7. 思考题
1. 为什么数学上等价的表达式在数值计算中会有如此大的差异？
A:因为数学等价性不考虑计算过程中的舍入误差和有限精度问题。不同的计算路径可能导致误差积累方式不同。
2. 在实际编程中，如何避免类似的数值不稳定性？
A:尽量避免相近大数的相减操作；选择数值稳定性更好的算法或表达式；使用更高精度的浮点数类型（如双精度、任意精度库）。
3. 除了本实验中的三种形式，你能想到其他数值更稳定的计算方式吗？
A:将级数分解为更简单的部分，或者使用递推公式。
## 附录：关键代码
```python
def sum_S1(N):
    """计算第一种形式的级数和：交错级数
    S_N^(1) = sum_{n=1}^{2N} (-1)^n * n/(n+1)
    
    参数:
        N (int): 求和项数
        
    返回:
        float: 级数和
    """
    # 学生在此实现第一种级数求和
    # 提示: 使用循环从1到2N，计算(-1)^n * n/(n+1)并累加
    total = 0.0
    for n in range(1, 2*N + 1):
        term = ((-1) ** n) * n / (n + 1)
        total += term
    return total

def sum_S2(N):
    """计算第二种形式的级数和：两项求和相减
    S_N^(2) = -sum_{n=1}^N (2n-1)/(2n) + sum_{n=1}^N (2n)/(2n+1)
    
    参数:
        N (int): 求和项数
        
    返回:
        float: 级数和
    """
    # 学生在此实现第二种级数求和
    # 提示: 
    # 1. 计算两个独立求和部分
    # 2. 将结果相减
    sum1 = 0.0
    sum2 = 0.0
    for n in range(1, N + 1):
        sum1 += (2*n - 1) / (2*n)
        sum2 += (2*n) / (2*n + 1)
    return sum2 - sum1

def sum_S3(N):
    """计算第三种形式的级数和：直接求和
    S_N^(3) = sum_{n=1}^N 1/(2n(2n+1))
    
    参数:
        N (int): 求和项数
        
    返回:
        float: 级数和
    """
    # 学生在此实现第三种级数求和
    # 提示: 使用循环从1到N，计算1/(2n(2n+1))并累加
    total = 0.0
    for n in range(1, N + 1):
        term = 1 / (2*n*(2*n + 1))
        total += term
    return total

def calculate_relative_errors(N_values):
    """计算相对误差
    
    参数:
        N_values (list): 不同N值列表
        
    返回:
        tuple: (err1, err2)
            err1: S1相对于S3的误差列表
            err2: S2相对于S3的误差列表
    """
    # 学生在此实现误差计算
    # 提示: 对每个N值计算三种级数和，然后计算相对误差
    err1 = []
    err2 = []
    
    for N in N_values:
        s1 = sum_S1(N)
        s2 = sum_S2(N)
        s3 = sum_S3(N)

        error1 = abs(s1 - s3) / abs(s3) if s3 != 0 else 0
        error2 = abs(s2 - s3) / abs(s3) if s3 != 0 else 0
        
        err1.append(error1)
        err2.append(error2)
    
    return (err1, err2)

def plot_errors(N_values, err1, err2):
    """绘制误差分析图
    
    参数:
        N_values (list): 不同N值列表
        err1 (list): S1相对于S3的误差列表
        err2 (list): S2相对于S3的误差列表
    """
    # 学生在此实现绘图功能
    # 提示:
    # 1. 使用plt.loglog绘制双对数坐标图
    # 2. 添加网格、标签和图例
    
    plt.figure(figsize=(10, 6))
    plt.loglog(N_values, err1, label='S1 relative error', marker='o', linestyle='-', color='blue')
    plt.loglog(N_values, err2, label='S2 relative error', marker='x', linestyle='--', color='red')
    
    plt.title('Analysis of Relative Errors in Series Summation')
    plt.xlabel('N value')
    plt.ylabel('relative error')
    plt.grid(True, which='both', linestyle='--', linewidth=0.5)
    plt.legend()


def print_results():
    """打印典型N值的计算结果"""
    # 学生在此实现结果打印
    # 提示:
    # 1. 选择几个典型N值(如10,100,1000,10000)
    # 2. 计算并格式化输出三种级数和及相对误差
    test_N = [10, 100, 1000, 10000]
    
    print("典型N值的计算结果：")
    print(f"{'N':<8} {'S1':<20} {'S2':<20} {'S3':<20} {'Err1':<20} {'Err2':<20}")
    print("-" * 100)
    
    for N in test_N:
        s1 = sum_S1(N)
        s2 = sum_S2(N)
        s3 = sum_S3(N)
        
        error1 = abs(s1 - s3) / abs(s3) if s3 != 0 else 0
        error2 = abs(s2 - s3) / abs(s3) if s3 != 0 else 0
        
        print(f"{N:<8} {s1:<20.15f} {s2:<20.15f} {s3:<20.15f} {error1:<20.15f} {error2:<20.15f}")

```
