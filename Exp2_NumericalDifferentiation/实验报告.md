# 实验二：数值微分的误差权衡

## 1. 实验目的
- 理解数值微分中截断误差与舍入误差的权衡关系
- 观察有限差分法计算导数时的误差变化规律
- 分析步长对数值微分精度的影响
- 确定最优步长范围

## 2. 实验方法
### 2.1 理论基础
数值微分是通过有限差分近似导数的计算方法。本实验实现了两种差分方法：
- 前向差分法: $f'(x) \approx \frac{f(x+\delta) - f(x)}{\delta}$
- 中心差分法: $f'(x) \approx \frac{f(x+\delta) - f(x-\delta)}{2\delta}$

### 2.2 测试函数
本实验使用函数 $f(x) = x(x-1)$，其解析导数为 $f'(x) = 2x - 1$。

### 2.3 实验步骤
1. 实现前向差分和中心差分函数
2. 在 $x=1$ 点计算不同步长下的数值导数
3. 计算数值导数与解析导数的相对误差
4. 绘制误差-步长关系图（对数坐标）
5. 分析最优步长和收敛阶数

## 3. 实验结果
### 3.1 数据表格
| 步长(δ) | 前向差分值 | 中心差分值 | 解析解 | 前向差分相对误差 | 中心差分相对误差 |
|---------|------------|------------|--------|------------------|------------------|
1.00e-02 | 1.010000 | 1.000000 | 1.00 | 1.00e-02 | 8.88e-16|
1.00e-03 | 1.001000 | 1.000000 | 1.00 | 1.00e-03 | 5.46e-14|
1.00e-04 | 1.000100 | 1.000000 | 1.00 | 1.00e-04 | 1.10e-13|
1.00e-05 | 1.000010 | 1.000000 | 1.00 | 1.00e-05 | 1.00e-12|
1.00e-06 | 1.000001 | 1.000000 | 1.00 | 1.00e-06 | 2.68e-11|
1.00e-07 | 1.000000 | 1.000000 | 1.00 | 1.01e-07 | 2.88e-11|
1.00e-08 | 1.000000 | 1.000000 | 1.00 | 3.92e-09 | 5.26e-10|
1.00e-09 | 1.000000 | 1.000000 | 1.00 | 8.37e-08 | 2.72e-08|
1.00e-10 | 1.000000 | 1.000000 | 1.00 | 8.28e-08 | 8.27e-08|
1.00e-11 | 1.000000 | 1.000000 | 1.00 | 8.28e-08 | 8.27e-08|
1.00e-12 | 1.000089 | 1.000033 | 1.00 | 8.89e-05 | 3.34e-05|
1.00e-13 | 0.999201 | 0.999756 | 1.00 | 7.99e-04 | 2.44e-04|
1.00e-14 | 0.999201 | 0.999201 | 1.00 | 7.99e-04 | 7.99e-04|

### 3.2 误差-步长关系图
（在此插入误差-步长关系图，并简要说明图中观察到的现象）
![image](https://github.com/user-attachments/assets/0c660f9d-ced8-4422-8b36-9ae475e1c288)

## 4. 分析与讨论
### 4.1 误差来源分析
数值微分中存在两种主要误差来源：
- **截断误差**：由于使用有限差分近似导数定义引入的误差，通常随步长减小而减小
- **舍入误差**：由于计算机浮点数表示的有限精度引入的误差，通常随步长减小而增大

（分析实验中观察到的截断误差和舍入误差的表现）
A:当步长较小时，舍入误差显著增大，而当步长较大时，截断误差显著增大。
### 4.2 前向差分与中心差分的比较
（比较两种方法的精度差异，并解释原因）
A:精度差异：中心差分方法的精度通常高于前向差分方法，因为中心差分方法的截断误差阶数更高。
  原因：中心差分方法使用对称的点对，能够更好地抵消高阶项的误差。
### 4.3 最优步长分析
（分析实验中观察到的最优步长，并解释为什么存在最优步长）
前向差分最优步长：1.00e-08，相对误差：3.922529e-09。中心差分最优步长：1.00e-02，相对误差：8.881784e-16
  原因：最优步长出现在截断误差和舍入误差达到平衡的点。
### 4.4 收敛阶数分析
（分析两种方法的收敛阶数，并与理论预期进行比较）
A:前向差分收敛阶数：约为 1.20。中心差分收敛阶数：约为 -0.65
  理论预期：前向差分的收敛阶数理论上为 1，中心差分的收敛阶数理论上为 2。实验结果与理论预期存在一定差异，可能是由于舍入误差的影响。
## 5. 实验结论
（总结本实验的主要发现，特别是关于误差权衡、最优步长和不同差分方法的优缺点）
A:误差权衡：数值微分中存在截断误差和舍入误差的权衡，最优步长出现在两者达到平衡的点。
最优步长范围：前向差分：1.00e-08。中心差分：1.00e-02。
方法比较：中心差分方法通常具有更高的精度，但对步长的选择更为敏感。前向差分方法虽然精度较低，但在某些情况下可能更稳定。
## 附录：核心代码片段
```python
# 前向差分法实现
def forward_diff(f, x, delta):
    return (f(x + delta) - f(x)) / delta

# 中心差分法实现
def central_diff(f, x, delta):
    return (f(x + delta) - f(x - delta)) / (2 * delta)

# 计算误差的代码
def calculate_errors(x_point=1.0):
    deltas = np.logspace(-2, -14, num=13)  
    forward_errors = []
    central_errors = []
    analytical_value = analytical_derivative(x_point)

    for delta in deltas:
        forward_value = forward_diff(f, x_point, delta)
        central_value = central_diff(f, x_point, delta)
        forward_errors.append(abs(forward_value - analytical_value) / abs(analytical_value))
        central_errors.append(abs(central_value - analytical_value) / abs(analytical_value))

    return deltas, forward_errors, central_errors

# 绘制误差-步长关系图的代码
 def plot_errors(deltas, forward_errors, central_errors):
    plt.figure(figsize=(10, 6))
    plt.loglog(deltas, forward_errors, marker='o', label='forward difference')
    plt.loglog(deltas, central_errors, marker='s', label='central difference')
    plt.xlabel('step size δ')
    plt.ylabel('relative error')
    plt.title('Error-step diagram')
    plt.legend()
    plt.grid(True)
    plt.savefig('error_vs_delta.png')  # 保存为 PNG 格式
    plt.show()

```
