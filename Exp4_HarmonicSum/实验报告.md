# 实验四：调和级数求和顺序与舍入误差实验报告

## 1. 实验目的
1. 实现并比较两种调和级数求和方法
2. 量化分析不同求和顺序导致的计算结果差异
3. 理解浮点数舍入误差的累积效应
4. 探究求和顺序对数值计算精度的影响

## 2. 实验原理
### 2.1 调和级数部分和
调和级数的前N项和定义为：

$$ S_N = \sum_{n=1}^{N} \frac{1}{n} $$

### 2.2 两种求和方法
1. 从小到大求和（ $S^{(up)}$）：

$$ S^{(up)} = \sum_{n=1}^{N}\frac{1}{n} = \frac{1}{1} + \frac{1}{2} + \frac{1}{3} + \cdots + \frac{1}{N} $$

2. 从大到小求和（ $S^{(down)}$）：

$$ S^{(down)} = \sum_{n=N}^{1}\frac{1}{n} = \frac{1}{N} + \frac{1}{N-1} + \cdots + \frac{1}{2} + \frac{1}{1} $$

### 2.3 相对差异计算
两种方法的相对差异定义为：

$$ \delta = \frac{|S^{(up)} - S^{(down)}|}{|(S^{(up)} + S^{(down)}) / 2|} $$

## 3. 实验方法
### 3.1 代码实现
- 实现 `sum_up(N)` 函数，从小到大计算调和级数和
- 实现 `sum_down(N)` 函数，从大到小计算调和级数和

### 3.2 数据收集
对不同的N值进行计算：
1. N值选取：使用 `np.logspace(1, 4, 50)` 在对数尺度上均匀取点
2. 计算并记录相对差异

## 4. 实验结果
### 4.1 数据记录

| N | $S^{(up)}$ | $S^{(down)}$ | 相对差异 δ |
|---|------------|--------------|------------|
| 10 |      2.928968253968254     |    2.928968253968254        |     0.000000000000000      |
| 100 |     5.187377517639621     |    5.187377517639622        |     0.000000000000000      |
| 1000 |    7.485470860550343     |    7.485470860550341        |     0.000000000000000      |
| 10000 |   9.787606036044348     |    9.787606036044386        |     0.000000000000004      |

### 4.2 误差分析图
（在此插入相对差异δ随N变化的双对数图）
![e88d29b15820d8c0e2b2fe0b3e075d5](https://github.com/user-attachments/assets/d71f6386-6f2c-4637-aefa-738f50aa14bd)

## 5. 分析与讨论
### 5.1 结果分析
1. 相对差异随N的变化趋势：
   - （分析图表趋势）
A:从图表中可以看出，随着N的增大，相对差异δ呈现出波动上升的趋势。当N较小时（如N < 100），相对差异δ非常小，几乎为零。这是因为此时累加的项数较少，舍入误差的影响不明显。当N增大到一定程度后（如N > 1000），相对差异δ开始逐渐增大，并呈现出一定的波动性。这表明随着累加项数的增加，舍入误差的累积效应开始显现。

2. 舍入误差累积效应：
   - （分析为什么 $S^{(down)}$更精确）
   - （结合浮点数表示方式解释）
A:因为当使用S^(up)时，较大的项先相加，随着累加和变得很大，再加上很小的1/N项时，浮点数的精度不足以表示这个小数部分，导致精度损失。相比之下，S^(down)先累加较小的项，这些小项的和可以更精确地表示。当加上较大的项时，累加和的规模与当前项的规模更为接近，浮点数能够更准确地表示这个和，从而减少了舍入误差的累积。
### 5.2 误差来源分析
1. 浮点数表示精度限制
   A:计算机中的浮点数具有有限的精度，无法精确表示所有实数。当进行浮点运算时，会引入舍入误差。
2. 加法运算中的舍入
   A:每次加法运算都会可能丢失精度，尤其是当两个数量级相差很大的数相加时。
3. 求和顺序的影响
   A:不同的求和顺序会影响误差的累积方式。S^(up)在累加后期加入小项时，累加和已经很大，导致小项的精度损失；而S ^(down)在累加前期加入小项，此时累加和较小，能够更好地保留小项的精度。

## 6. 结论
（总结实验发现，特别是关于求和顺序对计算精度的影响）
A:过实现两种调和级数求和方法并分析其相对差异，验证了求和顺序对数值计算精度的显著影响。实验结果表明，从大到小求和（S^(down)）通常比从小到大求和（S^(up)）更精确，这是因为S^(down)能够更好地避免浮点数加法中的精度损失。这一发现对于数值计算的实际应用具有重要意义，提醒我们在进行大规模数值计算时，应谨慎选择求和顺序以减小舍入误差的影响。
## 7. 思考题
1. 为什么从大到小求和通常能获得更好的精度？
A:从大到小求和时，较小的项先相加，这些小项的和可以更精确地表示。当加上较大的项时，累加和的规模与当前项的规模更为接近。
2. 在实际应用中，如何选择合适的求和策略来减小舍入误差？
A:可以先对项进行排序，然后从较小的项开始累加。
3. 除了改变求和顺序，还有什么方法可以提高数值计算的精度？
A:使用更高精度的浮点数类型（如双精度浮点数代替单精度浮点数）。采用数值稳定的算法，如Kahan求和算法、补偿求和算法等。
## 附录：关键代码
```python
def sum_up(N):
    """从小到大计算调和级数和
    
    参数:
        N (int): 求和项数
        
    返回:
        float: 调和级数和
    """
    # 学生在此实现从小到大求和
    # 提示: 使用循环从1加到N，每次加上1/n
    total = 0.0
    for n in range(1, N+1):
        total += 1.0 / n
    return total

def sum_down(N):
    """从大到小计算调和级数和
    
    参数:
        N (int): 求和项数
        
    返回:
        float: 调和级数和
    """
    # 学生在此实现从大到小求和
    # 提示: 使用循环从N减到1，每次加上1/n
    total = 0.0
    for n in range(N, 0, -1):
        total += 1.0 / n
    return total

def calculate_relative_difference(N):
    """计算两种方法的相对差异
    
    参数:
        N (int): 求和项数
        
    返回:
        float: 相对差异值
    """
    # 学生在此实现相对差异计算
    # 提示: 使用公式 |S_up - S_down| / ((S_up + S_down)/2)
    s_up = sum_up(N)
    s_down = sum_down(N)
    
    if s_up + s_down == 0:
        return 0.0
    
    return abs(s_up - s_down) / ((s_up + s_down) / 2)
    
def plot_differences():
    """绘制相对差异随N的变化"""
    # 学生在此实现绘图功能
    # 提示:
    # 1. 使用np.logspace生成N值
    # 2. 计算每个N对应的相对差异
    # 3. 使用plt.loglog绘制双对数坐标图
    N_values = np.logspace(1, 4, 50, dtype=int)
    
    relative_differences = [calculate_relative_difference(N) for N in N_values]

    plt.figure(figsize=(10, 6))
    plt.loglog(N_values, relative_differences, 'b-o', markersize=5, alpha=0.7)
    plt.xlabel('N (number of terms)', fontsize=12)
    plt.ylabel('relative differences δ', fontsize=12)
    plt.title('The influence of the summation order of harmonic series on relative differences', fontsize=14)
    plt.grid(True, which="both", linestyle='--', linewidth=0.5)
    plt.tight_layout()



def print_results():
    """打印典型N值的计算结果"""
    # 学生在此实现结果打印
    # 提示:
    # 1. 选择几个典型N值(如10,100,1000,10000)
    # 2. 计算并格式化输出两种方法的和及相对差异
    test_N = [10, 100, 1000, 10000]
    
    print(f"{'N':<10} | {'S_up':<20} | {'S_down':<20} | {'相对差异 δ':<20}")
    print("-" * 70)
    
    for N in test_N:
        s_up = sum_up(N)
        s_down = sum_down(N)
        delta = calculate_relative_difference(N)
        
        print(f"{N:<10} | {s_up:<20.15f} | {s_down:<20.15f} | {delta:<20.15f}")
```
