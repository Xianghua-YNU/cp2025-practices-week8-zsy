# 实验1: 二次方程求根的稳定性

## 1. 实验目的
1. 探究二次方程求根过程中可能出现的数值不稳定问题
2. 分析不同求根公式在不同参数条件下的误差表现
3. 理解数值计算中精度损失的原因及改进方法

## 2. 实验方法
1. 使用公式法求解二次方程 $ax^2+bx+c=0$ 的根
2. 实现两种不同的求根公式：
   - 标准求根公式： $x = \frac{-b \pm \sqrt{b^2-4ac}}{2a}$
   - 替换求根公式： $x = {2c\over-b\mp\sqrt{b^2-4ac}}$
3. 比较两种方法在不同参数条件下的数值稳定性，找到一种稳定的求根方法。

## 3. 实验结果
展示计算得到的主要数据、图表和观察现象。
 ![1fc5a1bb3fbf6097a0fb309e76a02fe](https://github.com/user-attachments/assets/3be18084-8ae1-4191-991c-b9a5140ecd58)
    
 ![image](https://github.com/user-attachments/assets/54299196-e01b-417e-ab18-dee4cd461774)

观察现象：1、标准公式在 b 很大时（如测试方程 2 和 3）会出现精度损失，导致一个根的计算结果误差较大。
2、替代公式在某些情况下能够提供更精确的结果，但在其他情况下也可能出现精度问题。
3、稳定求根程序通过选择适当的公式，能够有效避免数值不稳定性，提供更可靠的结果。


## 4. 分析与讨论
1. 分析两种方法在不同参数条件下的误差表现
   A:标准公式在 b 很大时，计算−b±(b^2−4ac)^(1/2)时，两个相近的数相减会导致有效数字的损失，从而引起精度问题。这种现象称为“灾难性抵消”。
    替代公式通过将分子和分母乘以−b∓(b^2−4ac)^(1/2)，避免了直接相减，从而在某些情况下提供了更精确的结果。然而，当 b 为负值时，替代公式也可能出现类似的
   稳定求根程序通过根据 b 的符号选择适当的公式，有效避免了数值不稳定性问题，确保了计算结果的精度。

3. 讨论数值计算中可能出现的问题及改进方法
   A:根据 b 的符号选择标准公式或替代公式，以避免直接相减导致的精度损失。在 a=0 的情况下，退化为一次方程求解，避免无效计算。

## 附录：核心代码片段
```python

def alternative_formula(a, b, c):
    """使用替代公式求解二次方程 ax^2 + bx + c = 0
    该方法通过将标准公式的分子和分母都乘以 -b∓√(b^2-4ac) 得到
    
    参数:
        a (float): 二次项系数
        b (float): 一次项系数
        c (float): 常数项
    
    返回:
        tuple: 方程的两个根 (x1, x2) 或 None(无实根)
    """
    # 学生在此处实现代码
    D = b**2 - 4*a*c
    
    if D < 0:
        return None 
    
    sqrt_D = np.sqrt(D)
    
    x1 = (2 * c) / (-b - sqrt_D)
    x2 = (2 * c) / (-b + sqrt_D)
    
    return (x1, x2)


def stable_formula(a, b, c):
    """稳定的二次方程求根程序，能够处理各种特殊情况和数值稳定性问题
    
    参数:
        a (float): 二次项系数
        b (float): 一次项系数
        c (float): 常数项
    
    返回:
        tuple: 方程的两个根 (x1, x2) 或 None(无实根)
    """
    # 学生在此处实现代码
    if abs(a) < 1e-10:
        if abs(b) < 1e-10:  # a ≈ 0 且 b ≈ 0
            return None if abs(c) > 1e-10 else (0, 0)  
        return (-c/b, -c/b) 
    
    # 计算判别式
    D = b**2 - 4*a*c
    
    if D < 0:
        return None  # 无实根

    sqrt_D = np.sqrt(D)
    
    if b > 0:
        x1 = (-b - sqrt_D) / (2*a)
        x2 = (2*c) / (-b - sqrt_D)
    else:
        x1 = (-b + sqrt_D) / (2*a)
        x2 = (2*c) / (-b + sqrt_D)
    
    return (min(x1, x2), max(x1, x2)) if x1 != x2 else (x1, x2)
```
